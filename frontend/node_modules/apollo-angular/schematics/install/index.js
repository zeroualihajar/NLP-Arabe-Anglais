"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.dependenciesMap = void 0;
const path_1 = require("path");
const schematics_1 = require("@angular-devkit/schematics");
const tasks_1 = require("@angular-devkit/schematics/tasks");
const ng_ast_utils_1 = require("@schematics/angular/utility/ng-ast-utils");
const core_1 = require("@angular-devkit/core");
const utils_1 = require("../utils");
const ast_1 = require("../utils/ast");
function install(options) {
    return schematics_1.chain([
        addDependencies(),
        inludeAsyncIterableLib(),
        allowSyntheticDefaultImports(),
        addSetupFiles(options),
        importSetupModule(options),
        importHttpClientModule(options),
    ]);
}
exports.default = install;
exports.dependenciesMap = {
    'apollo-angular': '^2.2.0',
    '@apollo/client': '^3.0.0',
    graphql: '^15.0.0',
};
/**
 * Add all necessary node packages
 * as dependencies in the package.json
 * and installs them by running `npm install`.
 */
function addDependencies() {
    return (host, context) => {
        const packageJsonPath = 'package.json';
        const packageJson = utils_1.getJsonFile(host, packageJsonPath);
        packageJson.dependencies = packageJson.dependencies || {};
        for (const dependency in exports.dependenciesMap) {
            if (exports.dependenciesMap.hasOwnProperty(dependency)) {
                const version = exports.dependenciesMap[dependency];
                if (!packageJson.dependencies[dependency]) {
                    packageJson.dependencies[dependency] = version;
                }
            }
        }
        // save the changed file
        host.overwrite(packageJsonPath, JSON.stringify(packageJson, null, 2));
        // schedule `npm install`
        context.addTask(new tasks_1.NodePackageInstallTask());
        return host;
    };
}
function inludeAsyncIterableLib() {
    return (host) => {
        const requiredLib = 'esnext.asynciterable';
        const tsconfigPath = 'tsconfig.json';
        const tsconfig = utils_1.getJsonFile(host, tsconfigPath);
        const compilerOptions = tsconfig.compilerOptions;
        if (compilerOptions &&
            compilerOptions.lib &&
            !compilerOptions.lib.find((lib) => lib.toLowerCase() === requiredLib)) {
            compilerOptions.lib.push(requiredLib);
            host.overwrite(tsconfigPath, JSON.stringify(tsconfig, null, 2));
        }
        else {
            const tsconfigBasePath = 'tsconfig.base.json';
            const tsconfigBase = utils_1.getJsonFile(host, tsconfigBasePath);
            const baseCompilerOptions = tsconfigBase.compilerOptions;
            if (baseCompilerOptions &&
                baseCompilerOptions.lib &&
                !baseCompilerOptions.lib.find((lib) => lib.toLowerCase() === requiredLib)) {
                baseCompilerOptions.lib.push(requiredLib);
                host.overwrite(tsconfigBasePath, JSON.stringify(tsconfigBase, null, 2));
            }
            else {
                console.error(core_1.terminal.yellow('\n' +
                    core_1.tags.stripIndent `
                We couln't find '${requiredLib}' in the list of library files to be included in the compilation.
                It's required by '@apollo/client/core' package so please add it to your tsconfig.
              ` +
                    '\n'));
            }
        }
        return host;
    };
}
function allowSyntheticDefaultImports() {
    return (host) => {
        const tsconfigPath = 'tsconfig.json';
        const tsconfig = utils_1.getJsonFile(host, tsconfigPath);
        const compilerOptions = tsconfig.compilerOptions;
        if (compilerOptions &&
            compilerOptions.lib &&
            !compilerOptions.allowSyntheticDefaultImports) {
            compilerOptions.allowSyntheticDefaultImports = true;
            host.overwrite(tsconfigPath, JSON.stringify(tsconfig, null, 2));
        }
        else {
            const tsconfigBasePath = 'tsconfig.base.json';
            const tsconfigBase = utils_1.getJsonFile(host, tsconfigBasePath);
            const baseCompilerOptions = tsconfigBase.compilerOptions;
            if (baseCompilerOptions &&
                baseCompilerOptions.lib &&
                !baseCompilerOptions.allowSyntheticDefaultImports) {
                baseCompilerOptions.allowSyntheticDefaultImports = true;
                host.overwrite(tsconfigBasePath, JSON.stringify(tsconfigBase, null, 2));
            }
            else {
                console.error(core_1.terminal.yellow('\n' +
                    core_1.tags.stripIndent `
                We couln't enable 'allowSyntheticDefaultImports' flag.
                It's required by '@apollo/client/core' package so please add it to your tsconfig.
              ` +
                    '\n'));
            }
        }
        return host;
    };
}
function addSetupFiles(options) {
    return (host) => {
        const mainPath = utils_1.getMainPath(host, options.project);
        const appModulePath = ng_ast_utils_1.getAppModulePath(host, mainPath);
        const appModuleDirectory = path_1.dirname(appModulePath);
        const templateSource = schematics_1.apply(schematics_1.url('./files'), [
            schematics_1.template({
                endpoint: options.endpoint,
            }),
            schematics_1.move(appModuleDirectory),
        ]);
        return schematics_1.mergeWith(templateSource);
    };
}
function importSetupModule(options) {
    return (host) => {
        ast_1.addModuleImportToRootModule(host, 'GraphQLModule', './graphql.module', options.project);
        return host;
    };
}
function importHttpClientModule(options) {
    return (host) => {
        ast_1.addModuleImportToRootModule(host, 'HttpClientModule', '@angular/common/http', options.project);
    };
}
//# sourceMappingURL=index.js.map