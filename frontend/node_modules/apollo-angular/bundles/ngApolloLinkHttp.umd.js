(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common/http'), require('@apollo/client/core'), require('graphql'), require('extract-files'), require('rxjs'), require('@apollo/client/link/batch')) :
    typeof define === 'function' && define.amd ? define('apollo-angular/http', ['exports', '@angular/core', '@angular/common/http', '@apollo/client/core', 'graphql', 'extract-files', 'rxjs', '@apollo/client/link/batch'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.ngApollo = global.ngApollo || {}, global.ngApollo.http = {}), global.ng.core, global.ng.common.http, global.core, global.graphql, global.extractFiles, global.rxjs, global.batch));
}(this, (function (exports, i0, i1, core, graphql, extractFiles, rxjs, batch) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    ;
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }
    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    var fetch = function (req, httpClient, extractFiles) {
        var shouldUseBody = ['POST', 'PUT', 'PATCH'].indexOf(req.method.toUpperCase()) !== -1;
        var shouldStringify = function (param) { return ['variables', 'extensions'].indexOf(param.toLowerCase()) !== -1; };
        var isBatching = req.body.length;
        var shouldUseMultipart = req.options && req.options.useMultipart;
        var multipartInfo;
        if (shouldUseMultipart) {
            if (isBatching) {
                return new rxjs.Observable(function (observer) { return observer.error(new Error('File upload is not available when combined with Batching')); });
            }
            if (!shouldUseBody) {
                return new rxjs.Observable(function (observer) { return observer.error(new Error('File upload is not available when GET is used')); });
            }
            multipartInfo = extractFiles(req.body);
            shouldUseMultipart = !!multipartInfo.files.size;
        }
        // `body` for some, `params` for others
        var bodyOrParams = {};
        if (isBatching) {
            if (!shouldUseBody) {
                return new rxjs.Observable(function (observer) { return observer.error(new Error('Batching is not available for GET requests')); });
            }
            bodyOrParams = {
                body: req.body,
            };
        }
        else {
            var body = shouldUseMultipart ? multipartInfo.clone : req.body;
            if (shouldUseBody) {
                bodyOrParams = {
                    body: body,
                };
            }
            else {
                var params = Object.keys(req.body).reduce(function (obj, param) {
                    var value = req.body[param];
                    obj[param] = shouldStringify(param) ? JSON.stringify(value) : value;
                    return obj;
                }, {});
                bodyOrParams = { params: params };
            }
        }
        if (shouldUseMultipart && shouldUseBody) {
            var form_1 = new FormData();
            form_1.append('operations', JSON.stringify(bodyOrParams.body));
            var map_1 = {};
            var files = multipartInfo.files;
            var i_1 = 0;
            files.forEach(function (paths) {
                map_1[++i_1] = paths;
            });
            form_1.append('map', JSON.stringify(map_1));
            i_1 = 0;
            files.forEach(function (_, file) {
                form_1.append(++i_1 + '', file, file.name);
            });
            bodyOrParams.body = form_1;
        }
        // create a request
        return httpClient.request(req.method, req.url, Object.assign(Object.assign({ observe: 'response', responseType: 'json', reportProgress: false }, bodyOrParams), req.options));
    };
    var mergeHeaders = function (source, destination) {
        if (source && destination) {
            var merged = destination
                .keys()
                .reduce(function (headers, name) { return headers.set(name, destination.getAll(name)); }, source);
            return merged;
        }
        return destination || source;
    };
    function prioritize() {
        var values = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            values[_i] = arguments[_i];
        }
        var picked = values.find(function (val) { return typeof val !== 'undefined'; });
        if (typeof picked === 'undefined') {
            return values[values.length - 1];
        }
        return picked;
    }
    function createHeadersWithClientAwereness(context) {
        // `apollographql-client-*` headers are automatically set if a
        // `clientAwareness` object is found in the context. These headers are
        // set first, followed by the rest of the headers pulled from
        // `context.headers`.
        var headers = context.headers && context.headers instanceof i1.HttpHeaders
            ? context.headers
            : new i1.HttpHeaders(context.headers);
        if (context.clientAwareness) {
            var _a = context.clientAwareness, name = _a.name, version = _a.version;
            // If desired, `apollographql-client-*` headers set by
            // the `clientAwareness` object can be overridden by
            // `apollographql-client-*` headers set in `context.headers`.
            if (name && !headers.has('apollographql-client-name')) {
                headers = headers.set('apollographql-client-name', name);
            }
            if (version && !headers.has('apollographql-client-version')) {
                headers = headers.set('apollographql-client-version', version);
            }
        }
        return headers;
    }

    // XXX find a better name for it
    var HttpLinkHandler = /** @class */ (function (_super) {
        __extends(HttpLinkHandler, _super);
        function HttpLinkHandler(httpClient, options) {
            var _this = _super.call(this) || this;
            _this.httpClient = httpClient;
            _this.options = options;
            _this.requester = function (operation) { return new core.Observable(function (observer) {
                var context = operation.getContext();
                // decides which value to pick, Context, Options or to just use the default
                var pick = function (key, init) {
                    return prioritize(context[key], _this.options[key], init);
                };
                var includeQuery = pick('includeQuery', true);
                var includeExtensions = pick('includeExtensions', false);
                var method = pick('method', 'POST');
                var url = pick('uri', 'graphql');
                var withCredentials = pick('withCredentials');
                var useMultipart = pick('useMultipart');
                var req = {
                    method: method,
                    url: typeof url === 'function' ? url(operation) : url,
                    body: {
                        operationName: operation.operationName,
                        variables: operation.variables,
                    },
                    options: {
                        withCredentials: withCredentials,
                        useMultipart: useMultipart,
                        headers: _this.options.headers,
                    },
                };
                if (includeExtensions) {
                    req.body.extensions = operation.extensions;
                }
                if (includeQuery) {
                    req.body.query = graphql.print(operation.query);
                }
                var headers = createHeadersWithClientAwereness(context);
                req.options.headers = mergeHeaders(req.options.headers, headers);
                var sub = fetch(req, _this.httpClient, extractFiles.extractFiles).subscribe({
                    next: function (response) {
                        operation.setContext({ response: response });
                        observer.next(response.body);
                    },
                    error: function (err) { return observer.error(err); },
                    complete: function () { return observer.complete(); },
                });
                return function () {
                    if (!sub.closed) {
                        sub.unsubscribe();
                    }
                };
            }); };
            return _this;
        }
        HttpLinkHandler.prototype.request = function (op) {
            return this.requester(op);
        };
        return HttpLinkHandler;
    }(core.ApolloLink));
    var HttpLink = /** @class */ (function () {
        function HttpLink(httpClient) {
            this.httpClient = httpClient;
        }
        HttpLink.prototype.create = function (options) {
            return new HttpLinkHandler(this.httpClient, options);
        };
        return HttpLink;
    }());
    HttpLink.ɵprov = i0.ɵɵdefineInjectable({ factory: function HttpLink_Factory() { return new HttpLink(i0.ɵɵinject(i1.HttpClient)); }, token: HttpLink, providedIn: "root" });
    HttpLink.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    HttpLink.ctorParameters = function () { return [
        { type: i1.HttpClient }
    ]; };

    var defaults = {
        batchInterval: 10,
        batchMax: 10,
        uri: 'graphql',
        method: 'POST',
    };
    var HttpBatchLinkHandler = /** @class */ (function (_super) {
        __extends(HttpBatchLinkHandler, _super);
        function HttpBatchLinkHandler(httpClient, options) {
            var _this = _super.call(this) || this;
            _this.httpClient = httpClient;
            _this.options = options;
            _this.batchInterval = options.batchInterval || defaults.batchInterval;
            _this.batchMax = options.batchMax || defaults.batchMax;
            var batchHandler = function (operations) {
                return new core.Observable(function (observer) {
                    var body = _this.createBody(operations);
                    var headers = _this.createHeaders(operations);
                    var _c = _this.createOptions(operations), method = _c.method, uri = _c.uri, withCredentials = _c.withCredentials;
                    if (typeof uri === 'function') {
                        throw new Error("Option 'uri' is a function, should be a string");
                    }
                    var req = {
                        method: method,
                        url: uri,
                        body: body,
                        options: {
                            withCredentials: withCredentials,
                            headers: headers,
                        },
                    };
                    var sub = fetch(req, _this.httpClient, function () {
                        throw new Error('File upload is not available when combined with Batching');
                    }).subscribe({
                        next: function (result) { return observer.next(result.body); },
                        error: function (err) { return observer.error(err); },
                        complete: function () { return observer.complete(); },
                    });
                    return function () {
                        if (!sub.closed) {
                            sub.unsubscribe();
                        }
                    };
                });
            };
            var batchKey = options.batchKey ||
                (function (operation) {
                    return _this.createBatchKey(operation);
                });
            _this.batcher = new batch.BatchLink({
                batchInterval: _this.batchInterval,
                batchMax: _this.batchMax,
                batchKey: batchKey,
                batchHandler: batchHandler,
            });
            return _this;
        }
        HttpBatchLinkHandler.prototype.createOptions = function (operations) {
            var context = operations[0].getContext();
            return {
                method: prioritize(context.method, this.options.method, defaults.method),
                uri: prioritize(context.uri, this.options.uri, defaults.uri),
                withCredentials: prioritize(context.withCredentials, this.options.withCredentials),
            };
        };
        HttpBatchLinkHandler.prototype.createBody = function (operations) {
            var _this = this;
            return operations.map(function (operation) {
                var includeExtensions = prioritize(operation.getContext().includeExtensions, _this.options.includeExtensions, false);
                var includeQuery = prioritize(operation.getContext().includeQuery, _this.options.includeQuery, true);
                var body = {
                    operationName: operation.operationName,
                    variables: operation.variables,
                };
                if (includeExtensions) {
                    body.extensions = operation.extensions;
                }
                if (includeQuery) {
                    body.query = graphql.print(operation.query);
                }
                return body;
            });
        };
        HttpBatchLinkHandler.prototype.createHeaders = function (operations) {
            var _a, _b;
            return operations.reduce(function (headers, operation) {
                return mergeHeaders(headers, operation.getContext().headers);
            }, createHeadersWithClientAwereness({
                headers: this.options.headers,
                clientAwareness: (_b = (_a = operations[0]) === null || _a === void 0 ? void 0 : _a.getContext()) === null || _b === void 0 ? void 0 : _b.clientAwareness,
            }));
        };
        HttpBatchLinkHandler.prototype.createBatchKey = function (operation) {
            var context = operation.getContext();
            if (context.skipBatching) {
                return Math.random().toString(36).substr(2, 9);
            }
            var headers = context.headers &&
                context.headers.keys().map(function (k) { return context.headers.get(k); });
            var opts = JSON.stringify({
                includeQuery: context.includeQuery,
                includeExtensions: context.includeExtensions,
                headers: headers,
            });
            return prioritize(context.uri, this.options.uri) + opts;
        };
        HttpBatchLinkHandler.prototype.request = function (op) {
            return this.batcher.request(op);
        };
        return HttpBatchLinkHandler;
    }(core.ApolloLink));
    var HttpBatchLink = /** @class */ (function () {
        function HttpBatchLink(httpClient) {
            this.httpClient = httpClient;
        }
        HttpBatchLink.prototype.create = function (options) {
            return new HttpBatchLinkHandler(this.httpClient, options);
        };
        return HttpBatchLink;
    }());
    HttpBatchLink.ɵprov = i0.ɵɵdefineInjectable({ factory: function HttpBatchLink_Factory() { return new HttpBatchLink(i0.ɵɵinject(i1.HttpClient)); }, token: HttpBatchLink, providedIn: "root" });
    HttpBatchLink.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    HttpBatchLink.ctorParameters = function () { return [
        { type: i1.HttpClient }
    ]; };

    // http

    /**
     * Generated bundle index. Do not edit.
     */

    exports.HttpBatchLink = HttpBatchLink;
    exports.HttpBatchLinkHandler = HttpBatchLinkHandler;
    exports.HttpLink = HttpLink;
    exports.HttpLinkHandler = HttpLinkHandler;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngApolloLinkHttp.umd.js.map
